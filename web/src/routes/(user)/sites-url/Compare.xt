<script lang="ts">
  import { goto } from '$app/navigation';
  import { focusTrap } from '$lib/actions/focus-trap';
  import { scrollMemory } from '$lib/actions/scroll-memory';
  import UserPageLayout from '$lib/components/layouts/user-page-layout.svelte';
  import {
    notificationController,
    NotificationType,
  } from '$lib/components/shared-components/notification/notification';

  import { modalManager } from '$lib/managers/modal-manager.svelte';
  import SiteUrlModal from '$lib/modals/SiteUrlModal.svelte';

  import { AppRoute } from '$lib/constants';
  import {
    deleteSitesUrl,
    downloadSitesUrl,
    getAllSitesUrl,
    type SitesUrlCreateDto,
    type SitesUrlResponseDto,
    type SitesUrlUpdateDto,
    updateSitesUrl,
    downloadSitesUrlByPreference,
    downloadAllSitesUrl,
  } from '@immich/sdk';
  import { mdiEyeOutline } from '@mdi/js';
  import { onMount } from 'svelte';
  import { t } from 'svelte-i18n';
  import { writable } from 'svelte/store';
  import type { PageData } from './$types';

  interface Props {
    data: PageData;
  }

  let { data }: Props = $props();

  const urls = writable<SitesUrlResponseDto[]>(data.urls);

  let search = $state('');
  let sortKey: keyof SitesUrlResponseDto = 'createdAt';
  let sortAsc = true;
  let pager = $state(1);
  let pageSize = 10;

  let isNew = false;
  let editingItem: SitesUrlCreateDto | SitesUrlResponseDto | null = null;
  let inlineEditingId: string | null = null;
  let selectedPreference = 0;

  async function fetchData() {
    try {
      const response = await getAllSitesUrl();
      $urls = response;
    } catch (err) {
      console.error('Failed to fetch:', err);
    }
  }

  function getFiltered() {
    return $urls
      .filter((item) =>
        Object.values(item)
          .filter((v) => v != null)
          .some((v) => v!.toString().toLowerCase().includes(search.toLowerCase())),
      )
      .sort((a, b) => {
        const aVal = a[sortKey];
        const bVal = b[sortKey];
        if (aVal == null) return 1;
        if (bVal == null) return -1;
        return sortAsc ? (aVal > bVal ? 1 : -1) : aVal < bVal ? 1 : -1;
      });
  }

  function getPaginated() {
    const filtered = getFiltered();
    const totalPages = Math.ceil(filtered.length / pageSize);
    return filtered.slice((pager - 1) * pageSize, pager * pageSize);
  }

  function toggleSort(key: keyof SitesUrlResponseDto) {
    if (sortKey === key) {
      sortAsc = !sortAsc;
    } else {
      sortKey = key;
      sortAsc = true;
    }
    pager = 1;
  }

  onMount(fetchData);

  const openCreateModal = async () => {
    const newSite: SitesUrlCreateDto = {
      url: 'https://',
      description: '',
      preference: 3,
      posts: 0,
      failed: false,
      lastDownloadedNode: '',
    };

    const savedUrl = await modalManager.show<SiteUrlModal>(SiteUrlModal, {
      newSiteUrl: newSite,
      isNew: true,
    });

    if (savedUrl) {
      $urls = [...$urls, savedUrl];
      pager = Math.ceil($urls.length / pageSize);
    }
    return savedUrl;
  };

  const openEditModal = async (item: SitesUrlResponseDto) => {
    const editingItem: SitesUrlUpdateDto = {
      id: item.id,
      url: item.url,
      description: item.description,
      preference: item.preference,
      posts: item.posts,
      failed: item.failed,
      lastDownloadedNode: item.lastDownloadedNode,
    };

    const savedUrl = await modalManager.show<{
      updateSiteUrl: SitesUrlUpdateDto;
      isNew: boolean;
      id?: string;
      onClose: (siteUrlUpdated?: SitesUrlCreateDto) => void;
    }>(SiteUrlModal, {
      updateSiteUrl: editingItem,
      isNew: false,
      id: item.id,
    });

    if (savedUrl) {
      $urls = $urls.map((u) => (u.id === item.id ? savedUrl : u));
      pager = Math.ceil($urls.length / pageSize);
    }
  };

  function openInlineEdit(item: SitesUrlResponseDto) {
    inlineEditingId = item.id;
    editingItem = { ...item };
    isNew = false;
  }

  async function deleteRow(id: string) {
    await deleteSitesUrl({ id });
    await fetchData();
    pager = 1;
  }

  async function downlodadUrl(id: string) {
    try {
      await downloadSitesUrl({ id });
      notificationController.show({
        type: NotificationType.Info,
        message: 'Download started successfully',
      });
    } catch (err) {
      console.error('Download failed:', err);
      notificationController.show({
        type: NotificationType.Error,
        message: 'Download failed',
      });
    }
  }

  async function saveInlineEdit(item: SitesUrlResponseDto) {
    inlineEditingId = null;
    try {
      const payload: SitesUrlUpdateDto = {
        url: item.url,
        posts: item.posts,
        description: item.description,
        preference: Number(item.preference),
      };

      if (payload.preference < 1 || payload.preference > 5) {
        throw new Error('Preference must be between 1 and 5');
      }

      const updated = await updateSitesUrl({ id: item.id, sitesUrlUpdateDto: payload });

      $urls = $urls.map((u) => (u.id === updated.id ? updated : u));
    } catch (err) {
      console.error('Inline update failed', err);
      notificationController.show({
        type: NotificationType.Error,
        message: 'Inline update failed',
      });
    }
  }

  async function downloadAll() {
    try {
      await downloadAllSitesUrl();
      notificationController.show({
        type: NotificationType.Info,
        message: 'All downloads started successfully',
      });
    } catch (err) {
      console.error('Download all failed:', err);
      notificationController.show({
        type: NotificationType.Error,
        message: 'Download all failed',
      });
    }
  }

  async function downloadPriority() {
    try {
      await downloadSitesUrlByPreference({ preference: 0 });
      notificationController.show({
        type: NotificationType.Info,
        message: 'Priority download started',
      });
    } catch (err) {
      console.error('Priority download failed:', err);
      notificationController.show({
        type: NotificationType.Error,
        message: 'Priority download failed',
      });
    }
  }

  async function downloadBySelectedPreference() {
    try {
      await downloadSitesUrlByPreference({ preference: selectedPreference });
      notificationController.show({
        type: NotificationType.Info,
        message: `Download started for preference ${selectedPreference}`,
      });
    } catch (err) {
      console.error('Download by preference failed:', err);
      notificationController.show({
        type: NotificationType.Error,
        message: 'Download by preference failed',
      });
    }
  }
</script>

<!-- Pagination Controls -->
<div class="mt-4 flex items-center justify-between flex-wrap gap-2">
  <div class="flex gap-2">
    <button on:click={() => (pager = Math.max(1, pager - 1))} disabled={pager === 1}>Previous</button>
    <span>Page {pager}</span>
    <button on:click={() => (pager += 1)} disabled={pager * pageSize >= getFiltered().length}>Next</button>
  </div>
  <div class="flex gap-2 flex-wrap">
    <button class="px-4 py-2 bg-blue-500 text-white rounded" on:click={openCreateModal}>Add New</button>
    <button class="px-4 py-2 bg-green-500 text-white rounded" on:click={downloadAll}>Download All</button>
    <button class="px-4 py-2 bg-orange-500 text-white rounded" on:click={downloadPriority}>Download Priority</button>
    <div class="flex items-center gap-2">
      <label for="preference" class="text-sm font-medium">Preference:</label>
      <select
        id="preference"
        class="border rounded px-2 py-1"
        bind:value={selectedPreference}
      >
        <option value="0">0 (All)</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>
      <button
        class="px-4 py-2 bg-purple-500 text-white rounded"
        on:click={downloadBySelectedPreference}
      >
        Download by Preference
      </button>
    </div>
  </div>
</div>


<!-- Pagination Controls -->
<div class="mt-4 flex items-center justify-between flex-wrap gap-2">
  <div class="flex gap-2">
    <button on:click={() => (pager = Math.max(1, pager - 1))} disabled={pager === 1}>Previous</button>
    <span>Page {pager}</span>
    <button on:click={() => (pager += 1)} disabled={pager * pageSize >= getFiltered().length}>Next</button>
  </div>
  <div class="flex gap-2 flex-wrap">
    <button class="px-4 py-2 bg-blue-500 text-white rounded" on:click={openCreateModal}>Add New</button>
    <button class="px-4 py-2 bg-green-500 text-white rounded" on:click={downloadAll}>Download All</button>
    <button class="px-4 py-2 bg-orange-500 text-white rounded" on:click={downloadPriority}>Download Priority</button>
    <div class="flex items-center gap-2">
      <label for="preference" class="text-sm font-medium">Preference:</label>
      <select
        id="preference"
        class="border rounded px-2 py-1"
        bind:value={selectedPreference}
      >
        <option value="0">0 (All)</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>
      <button
        class="px-4 py-2 bg-purple-500 text-white rounded"
        on:click={downloadBySelectedPreference}
      >
        Download by Preference
      </button>
    </div>
  </div>
</div>
